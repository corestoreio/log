// Copyright 2015-2016, Cyrill @ Schumacher.fm and the CoreStore contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package logw

// Most of this code can be improved to fits the needs for others. Main reason
// for implementing this was to provide a basic leveled logger without any
// dependencies to third party packages.

import (
	"io"
	std "log"
	"os"

	"github.com/corestoreio/log"
)

const (
	LevelFatal int = iota + 1
	LevelInfo
	LevelDebug
)

// Log implements logging with Go's standard library
type Log struct {
	gw    io.Writer // global writer
	level int
	flag  int // global flag http://golang.org/pkg/log/#pkg-constants
	debug *std.Logger
	info  *std.Logger
	// ctx is only set when we act as a child logger
	ctx log.Fields
}

// Option can be used as an argument in NewLog to configure a standard logger.
type Option func(*Log)

// NewLog creates a new logger with 6 different sub loggers.
// You can use option functions to modify each logger independently.
// Default output goes to Stderr.
func NewLog(opts ...Option) *Log {
	sl := &Log{
		level: LevelInfo,
		gw:    os.Stderr,
		flag:  std.LstdFlags,
	}
	for _, o := range opts {
		o(sl)
	}
	if sl.debug == nil {
		sl.debug = std.New(sl.gw, "DEBUG ", sl.flag)
	}
	if sl.info == nil {
		sl.info = std.New(sl.gw, "INFO ", sl.flag)
	}
	return sl
}

// SetWriter sets the global writer for all loggers. This global writer can be
// overwritten by individual level options.
func WithWriter(w io.Writer) Option {
	return func(l *Log) {
		l.gw = w
	}
}

// WithFlag sets the global flag for all loggers.
// These flags define which text to prefix to each log entry generated by the Logger.
// This global flag can be overwritten by individual level options.
// Please see http://golang.org/pkg/log/#pkg-constants
func WithFlag(f int) Option {
	return func(l *Log) {
		l.flag = f
	}
}

// WithLevel sets the log level. See constants Level*
func WithLevel(level int) Option {
	return func(l *Log) {
		l.level = level
	}
}

// WithDebug applies options for debug logging
func WithDebug(out io.Writer, prefix string, flag int) Option {
	return func(l *Log) {
		l.debug = std.New(out, prefix, flag)
	}
}

// WithInfo applies options for info logging
func WithInfo(out io.Writer, prefix string, flag int) Option {
	return func(l *Log) {
		l.info = std.New(out, prefix, flag)
	}
}

// WithFields adds fields as a logging prefix to the internal stack.
func WithFields(fields ...log.Field) Option {
	return func(l *Log) {
		l.ctx = append(l.ctx, fields...)
	}
}

// With creates a new inherited and shallow copied Logger with additional fields
// added to the logging context.
func (l *Log) With(fields ...log.Field) log.Logger {
	l2 := new(Log)
	*l2 = *l
	l2.ctx = append(l2.ctx, fields...)
	return l2
}

// Debug logs a debug entry.
func (l *Log) Debug(msg string, fields ...log.Field) {
	l.log(LevelDebug, msg, fields)
}

// Info logs an info entry.
func (l *Log) Info(msg string, fields ...log.Field) {
	l.log(LevelInfo, msg, fields)
}

// log logs a leveled entry. Panics if an unknown level has been provided.
func (l *Log) log(level int, msg string, fs log.Fields) {

	if ctxl := len(l.ctx); ctxl > 0 {
		all := make(log.Fields, 0, ctxl+len(fs))
		all = append(all, l.ctx...)
		all = append(all, fs...)
		fs = all
	}

	if l.level >= level {
		switch level {
		case LevelDebug:
			// l.debug.Print(stdFormat(msg, append(args, "in", getStackTrace())))
			l.debug.Print(fs.ToString(msg))
		case LevelInfo:
			l.info.Print(fs.ToString(msg))
		default:
			panic("[logw] Unknown Log Level")
		}
	}
}

// IsDebug determines if this logger logs a debug statement.
func (l *Log) IsDebug() bool {
	return l.level >= LevelDebug
}

// IsInfo determines if this logger logs an info statement.
func (l *Log) IsInfo() bool {
	return l.level >= LevelInfo
}
